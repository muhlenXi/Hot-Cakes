### 程序员修炼之道-读书笔记 

#### 前言：

> 程序员修炼之道-从小工到专家，是一本初学者、中高级开发人员或软件项目经理都可以读的书。本书涵盖的主题从个人责任、职业发展、直到用于使代码保持灵活、并且易于改编和复用的各种框架技术，利用许多富有娱乐性的奇闻轶事、有思想的例子及有趣的类比，全面阐述了软件开发的许多不同方面的最佳实践和重大陷阱。


#### 正文

何为经典书或上品？

> 经典书指的是选材精良、内容精炼、讲述生动、外延丰盛、表现手法体贴入微的读品，它们会成为读者的知识和经验库的重要组成部分，并且拥有从不断重读中汲取养分的空间。

*注重实效的程序员应该不断学习！*

能不能让正确的原则指导正确的行动本身，其实就是区分是否是高手的一个显著标志。

注重实效不应该局限于任何特定的技术，而是应该拥有足够广博的背景和经验基础。

你的背景源于对计算机科学的基本原理的理解。你的经验来自广泛的实际项目。理论与实践的结合使你强大起来。

*注重实效的程序员的特征*

* 1、早期的采纳者/快速的改编者。
* 2、好奇。
* 3、批判的思考者。
* 4、有现实感。
* 5、多才多艺。

*Notice 1:* 关心你的技艺

> Care About Your Craft.
> 
> 如果你不在乎能否漂亮地开发出软件，你又为何要耗费生命去开发软件呢？

*Notice 2:* 思考你的工作.

> Think! About Your Work. 
> 
> 关掉自动驾驶仪，接管操作。不断地批评和评估你的工作。

##### 1、我的源码让猫吃了

*Notice 3:* 提供各种选择，而不是蹩脚的借口。

> Provide Options, Don't Make Lame Excuses. 
> 
> 要提供各种选择，而不是找借口。不要说事情做不到；说明能够做什么。

##### 2、软件的熵

*Notice 4:* 不要容忍破窗户

> Don't Live with Broken Windows. 
> 
> 当你看到糟糕的设计、错误的决策和糟糕的代码时，修正它们。


##### 3、石头汤与煮青蛙

*Notice 5:* 做变化的催化剂

> Be a Catalyst for Change. 
> 
> 你不能强迫人们改变。相反你可以向他们展示未来可能会怎么样，并帮助他们参与对未来的创造。

*Notice 6:* 记住大图景

> Remember the Big Picture. 
> 
> 不要太过专注细节，以致忘了查看你周围正在发生什么。 

##### 4、足够好的软件

*Notice 7:* 使质量成为需求问题

> Make Quality a Requirements Issue. 
> 
> 让你的用户参与确定项目真正的质量需求。 

##### 5、你的知识财产

*Notice 8:* 定期为你的知识资产投资

> Invest Regularly in Your Knowledge Portfolio. 
> 
> 让学习成为习惯。

*Notice 9:* 批判的分析你读到的和听到的

> Critically Analyze What You Read and Hear. 
> 
> 不要被供应商、媒体炒作、或教条左右。要按照你自己的看法和你的项目的情况去对信息进行分析。

经营资产的方法：

* 1、定期投资
* 2、多元化
* 3、管理风险。
* 4、低买高卖。
* 5、重新评估和平衡。

##### 6、交流

*Notice 10:* 你说什么和你怎么说同样重要

> It‘s Both What You Say and the Way You Say it. 
> 
> 如果你不能有效地向他人传达你了不起的想法，这些想法就毫无用处。

总结：

* 知道你想要说什么。

　　*不断反问自己：“这是否讲清了我要说的所有内容？”*

* 了解你的听众。

    你想让他们学到什么？

    他们对你讲的什么感兴趣？

    他们有多富有经验？

    他们想要多少细节？

    你想让谁拥有这些信息？

    你如何促使他们听你说话？

* 选择时机。
* 选择风格。
* 让文档美观。
* 让听众参与。
* 做倾听者。
* 回复他人。

##### 7、重复的危害

*Notice 11:* 不要重复你自己

> DRY - Don't Repeat Yourself.  
> 
> 系统中的每一项知识都必须具有单一、无歧义、权威的表示。

*Notice 12:* 让复用变得容易。

> Make It Easy to Reuse.  
> 
> 如果复用很容易，人们就会去复用。创造一个支持复用的环境。

##### 8、正交性

*Notice 13:* 消除无关事物之间的影响。

> Eliminate Effects Between Unrelated Things. 
> 
> 设计自足、独立、并具有单一、良好定义的目的的组件。 

*注意事项:*

* 让你的代码保持解耦

* 避免使用全局数据

* 避免编写相似的函数。

##### 9、可撤销性

*Notice 14:* 不存在最终决策。

> There Are No Final Decisions.  
> 
> 没有决策时浇筑在石头上的。相反，要把每项决策都视为写在沙滩上的，并为变化做好计划。

##### 10、曳光弹

*Notice 15:* 用曳光弹找到目标。

> Use Tracer Bullets to Find the Target. 
> 
> 曳光弹能通过试验各种事物并检查它们离目标有多远来让你追踪目标。

优点：

* 1、用户能够及早看到能工作的东西。
* 2、开发者构建了一个他们能在其中工作的结构。
* 3、你有了一个集成平台。
* 4、你有了可用于演示的东西。
* 5、你将更能够感觉到工作进展。

##### 11、原型与便签

*Notice 16:* 为了学习而制作模型。

> Prototype to Learn. 
> 
> 原型制作是一种学习经验。其价值并不在于所产生的代码，而在于所学到的经验教训。

*应制作原型的事物：架构、已有系统中的新功能、外部数据的结构或内容、第三方工具或组件、性能问题、用户界面设计。*

##### 12、领域语言

> 语言的界限就是一个人的世界的界限。  --- 维特根斯坦

*Notice 17:* 靠近问题领域编程

> Program Close to the Problem domain.
> 
> 用你的用户的语言进行设计和编码。



##### 13、估算

*Notice 18:* 估算，以避免意外

> Estimate to Avoid Surprises.
> 
> 在着手之前先进行估算。你将提前发现潜在的问题。  

*Notice 19:* 通过代码对进度表进行迭代

> Iterate the Schedule with the code
> 
> 用你在进行实现时获得的经验提炼项目的时间标度。 

##### 14、纯文本的威力

*Notice 20:* 用纯文本保存知识

> Keep Knowledge in Plain Text. 
> 
> 纯文本不会过时。它能够帮助你有效利用你的工作，并简化调试和测试。

##### 15、shell游戏

*Notice 21:* 利用命令shell的力量

> Use the Power of Command Shells. 
> 
> 当图形界面无能为力时使用shell。

##### 16、强力编辑

*Notice 22:* 用好一种编辑器

> Use a Single Editor Well. 
> 
> 编辑器应该是你的手的延伸；确保你的编辑器是可配置、可扩展和可编程的。

##### 17、源码控制

*Notice 23:* 总是使用源码控制

> Always User Source Code Control. 
> 
> 源码控制是你的工作的时间机器---你能够回到过去。

##### 18、调试

*Notice 24:* 要修正问题，而不是发出指责

> Fix the Problem，Not the Blame.
> 
> 是你的过错还是别人的过错，并不是真的很有关系---它仍然是你的问题，它仍然需要修正。 

*Notice 25:* 不要恐慌

> Don't Panic.  
> 
> 做一次深呼吸，思考什么可能是 bug 的原因。

*Notice 26:* "Select" 没有问题

> "Select" Isn't Broken. 
> 
> 在OS或编译器、甚至是第三方产品或库中很少发现bug。bug很可能是在应用中。

*Notice 27:* 不要假定，要证明

> Don't Assume it - Prove It. 
> 
> 在实际环境中---使用真正的数据和边界条件---证明你的假定。

##### 19、文本操纵

*Notice 28:* 学习一种文本操作语言

> Learn a Text Manipulation Language. 
> 
> 你用每天的很大一部分时间处理文本，为什么不让计算机替你完成部分工作呢？

##### 20、代码生成器

*Notice 29:* 编写能编写代码的代码

> Write Code That Writes Code.
> 
> 代码生成器能提高你的生产率，并有助于避免重复。  


*Notice 30:* 你不可能写出完美的软件

> You Can't Write Perfect Software.
> 
> 软件不可能完美。保护你的代码和用户，使它（他）们免于能够遇见的错误。


##### 21、按合约设计 （Design By Contract） 

*Notice 31:* 通过合约进行设计

> Design with contracts.
> 
> 使用合约建立文档，并检验代码所做的事情正好是它声明要做的。 

##### 22、死程序不说谎

*Notice 32:* 早崩溃

> Crash Early.
> 
> 死程序造成的危害通常比有问题的程序要小的多。

##### 23、断言式编程

*Notice 33:* 用断言避免不可能发生的事情

> If It Can't Happen, Use Assertions to Ensure That It Won't. 
> 
> 断言验证你的各种假设。在一个不确定的世界里，用断言保护你的代码。

##### 24、何时使用异常

*Notice 34:* 将异常用于异常的问题

> Use Exceptions for Exceptional Problems.
> 
> 异常可能会遭受经典的意大利面条式代码的所有可读性和可维护问题的折磨。将异常保留给异常的事物。 
 
##### 25、怎样配平资源

*Notice 35:* 要有始有终

> Finish What You Start. 
> 
> 只要可能，分配某资源的例程或对象也应该负责解除其分配。

##### 26、解耦与得墨忒耳法则

*Notice 36:* 使模块之间的耦合减至最少

> Minimize Coupling Between Modules.
> 
> 通过编写“羞怯的”代码并应用得墨忒尔法则来避免耦合。  

#### 27、元程序设计

*Notice 37:* 要配置，不要集成

> Configure, Don't Integrate.
> 
> 要将应用的各种技术选择实现为配置选项，而不是通过集成或工程方法实现。  

*Notice 38:* 将抽象放进代码，细节放进元数据

> Put Abstractions in Code, Details in Metadata.
> 
> 为一般情况编程，将细节放在被编译的代码库之外。 


#### 28、时间耦合

*Notice 39:* 分析工作流，以改善并发性

> Analyze Workflow to Improve Concurrency. 
> 
> 利用你的用户的工作流中的并发性。

*Notice 40:* 用服务进行设计

> Design Using Services.
> 
> 根据服务---独立的、在良好定义、一致的接口之后的并发对象---进行设计。 

*Notice 41:* 总是为并发进行设计

> Always Design for Concurrency.
> 
> 容许并发，你将会设计出更整洁、具有更少假定的接口。 

#### 29、它只是视图

*Notice 42:* 使视图与模型分离

> Separate Views from Models. 
> 
> 要根据模型和视图设计你的应用，从而以低廉的代码获取灵活性。

#### 30、黑板

*Notice 43:* 用黑板协调工作流

> Use Blackboards to Coordinate Workflow. 
> 
> 用黑板协调完全不同的事实和因素，同时又使各参与方保持独立和隔离。

#### 31、靠巧合编程

*Notice 44:* 不要靠巧合编程

> Don't Program by Coincidence.
> 
> 只依靠可靠的事物。注意偶发的复杂性，不要把幸运的巧合与有目的的计划混为一谈。 

#### 32、算法速率

*Notice 45:* 估算你的算法的阶

> Estimate the Order of Your Algorithms.
> 
> 在你编写代码之前，先大致估算事情需要多长时间。  

*Notice 46:* 测试你的估算

> Test Your Estimates. 
> 
> 对算法的数学分析并不会告诉你每一件事情。在你的代码的目标环境中测定它的速度。

#### 33、重构

*重写、重做和重新架构代码合起来，称为重构（refactoring）。*

*Notice 47:* 早重构，常重构

> Refactor Early，Refactor often.
> 
> 就和你会在花园中除草、并重新布置一样，在需要时对代码进行重写、重做和重新架构。要铲除问题的根源。

#### 34、易于测试的代码

*Notice 48:* 为测试而设计

> Design to Test.
> 
> 在你还没有编写代码时就开始思考测试问题。 

*Notice 49:*  测试你的软件，否则你的用户就得测试

> Test Your Software,or Your Users Will.
> 
> 无情的测试。不要让你的用户为你查找bug。

#### 35、易于测试的代码

*Notice 50:* 不要使用你不理解的向导代码

> Don't Use Wizard Code You Don't Understand.
> 
> 向导可以生成大量代码。在你把他们合并进你的项目之前，确保你理解全部这些代码。 


#### 36、需求之坑

*Notice 51:* 不要搜集需求---挖掘它们

> Don't Gather Requirements - Dig for Them.
> 
> 需求很少存在于表面上。他们深深地埋藏在层层假定、误解和政治手段的下面。


*Notice 52:* 与用户一同工作，以像用户一样思考

> Work with a User to Think Like a User.
> 
> 要了解系统实际上将如何被使用，这是最好的方法。

*Notice 53:* 抽象比细节活的更长久

> Abstractions Live Longer than Details.
> 
> “投资”于抽象，而不是实现。抽象能在来自不同的实现和新技术的变化的“攻击”之下存活下去。

*Notice 54:* 使用项目词汇表

> Use a Project Glossary.
> 
> 创建并维护项目中使用的专用术语和词汇的单一信息源。


#### 37、解开不可能解开的谜题

*Notice 55:* 不要在盒子外面思考---要找到盒子

> Don't Think Outside the Box - Find the Box.
> 
> 在遇到不可能解决的问题时，要确定真正的约束。问问你自己：“它必须以这种方式完成么？它真的必须完成吗？” 

#### 38、等你准备好

*Notice 56:* 倾听反复出现的疑虑---等你准备好再开始

> Listen to Nagging Doubts - Start When You're Ready.
> 
> 你的一生都在积累经验。不要忽视反复出现的疑虑。

#### 39、规范陷阱

*Notice 57:* 对有些事情“做”胜于“描述”。

> Some Things Are Better Done than Described.
> 
> 不要掉进规范的螺旋---在某个时刻，你需要开始编码。

#### 40、圆圈与箭头

*Notice 58:* 不要做形式方法的奴隶

> Don't Be a Slave to Formal Methods.
> 
> 如果你没有把某项技术放进你的开发实践和能力的语境中，不要盲目地采用它。

*Notice 59:* 昂贵的工具不一定能制造出更好的设计

> Expensive Tools Do Not Produce Better Designs.
> 
> 小心供应商的炒作，行业教条，以及价格标签的诱惑。要根据工具的价值判断它们。


#### 41、注重实效的团队

*Notice 60:* 围绕功能、而不是工作职务进行组织

> Organize Around Functionality,Not Job Functions.
> 
> 不要把设计师和编码员分开，也不要把测试员与数据建模员分开。按照你构建代码的方式构建团队。

##### 42、无处不在的自动化

*Notice 61:* 不要使用手工流程

> Don't Use Manual Procedures.
> 
> shell 脚本或批文件会一次次地以同一顺序执行同样的指令。

##### 43、无情的测试

*Notice 62:* 早测试，常测试，自动测试。

> Test Early，Test More，Test Automatically. 
> 
>  与呆在书架上的测试计划相比，每次构建时运行的测试要有效得多。

*Notice 63:* 要通过全部测试，编码才算完成。

> Coding Ain't Done Til All the Tests Run.
> 
>  就是这样

*Notice 64:* 通过蓄意破坏测试你的测试。

> User Saboteurs to Test Your Testing.
> 
> 在单独的软件副本上故意引入bug，以检验测试能否抓住它们。

*Notice 65:* 测试状态覆盖。而不是代码覆盖。

> Test State Coverage，Not Code Coverage.
> 
> 确定并测试重要的程序状态。只是测试代码行是不够的。

*Notice 66:* 一个 bug 只抓住一次。

> Find Bugs Once.
> 
> 一旦测试员找到一个bug，这应该是测试员最后一次找到它。此后自动测试应该对其进行检查。

##### 44、全都是写

*Notice 67:* 把英语当作又一种编程语言。

> Treat English as Just Another Programming Language .
> 
> 像你编写代码一样编写文档：遵守DRY原则、使用元数据、MVC、自动生成等等 。

*Notice 68:* 把文档建在里面，不要拴在外面。

> Build Documentation In，Don't Bolt It On. 
> 
>  与代码分离的文档不太可能被修正和更新。

##### 45、极大的期望

*Notice 69:* 温和地超出用户的期望。

> Gently Exceed Your Users’ Expectations. 
> 
>  要理解你的用户的期望，然后给他们的东西要多那么一点。

##### 46、傲慢与偏见

*Notice 70:* 在你的作品上签名。

> Sign Your Work. 
> 
> 过去时代的手艺人在能为他们的作品上签名而自豪 。你也应该如此。


#### 结束语

*读完一本书不难。难得就是在生活中去践行书中的方法论，去验证是否说的有道理，希望自己在以后的生活和学习中能够慢一些、收获多一些。*
